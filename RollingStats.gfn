<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="RollingStats" needs-time-series-data="true" minver="2018d">
<author email="atecon@cryptolab.net">Artur Tarassow</author>
<version>0.2</version>
<date>2019-01-11</date>
<description>Rolling Time-Series Statistics</description>
<tags>C10</tags>
<label>Rolling Time-series Stats</label>
<menu-attachment>MAINWIN/Add</menu-attachment>
<help>
===============================
&quot;RollingStats&quot; -- Gretl package
===============================

Author: Artur Tarassow
Email: atecon@cryptolab.net
Web: https://sites.google.com/site/arturtarassow/

version history
****************
0.2: Jan., 2019
+ Work on rolling_ts():
	- 'y' can be a list of series now
	- the output matrix can be a matrix of size R by n
	instead of R by 1
	- the user may provide a matrix array in pointer form
	for storing multiple matrices returned by some
	user-defined function
	+ update the sample script and manual script accordingly
0.1: Nov., 2018
+ initial public version


Public functions:
*****************
rolling_ts(): Rolling Univariate Time-series Statistics
-------------
+ This function allows the user to compute specific statistics
in either a 'rolling' (fixed, shifting window through time) or
'recursive' (expanding window through time) manner.
+ In principle all -- both built-in as well as user-defined
functions (UDF) -- can be called which have a scalar value as
its outcome.

rvec2series():
--------------
+ Transforms an R by 1 vector into a series
+ For a list of series, use a loop calling rvec2series() multiple
times instead

rolling_ts_gui():
---------------
+ Access rolling_ts() and rvec2series() through the GUI
+ NOTE: only a single series is allowed as input instead of a list
of series

-----------------
rolling_ts():
-----------------
INPUT:
list y: 		list of series which is used for computing
			some statistics
string op:		string, name of the function you want to call
int wsize[1::2]:	integer, size of the moving window (default 2
			periods)
bool recursive[0]:	0: rolling-window (default), 1: recursive
			(expanding) window
recursive[0]:		0: rolling-window (default), 1: recursive
			(expanding) window
matrices *M[null]:	matrix array in pointer form for storing
			multiple matrices returned by 'op'

OUTPUT:
+ In case no matrix array *M is given to rolling_ts(), a R by k
matrix where R refers to the number of moving windows and k is
some output vector returned by the operation 'op' is returned.
+ In case a matrix array *M is sent to rolling_ts(), the output
matrix is 1 by 1 with an NA entry, and all information are stored
in the matrix array M, instead.
Note for this case one can also just run the command
'rolling_ts(y, op, wsize, recursive, &amp;M)' without referencing
to any matrix, as information is stored in the array M.


-----------------
rvec2series():
-----------------
INPUT:
series y: 		series with R observations which is used for
			date referencing vector in m correctly
matrix m:		matrix, R by 1 vector comprising the computed
			statistics
int wsize[1::2]:	integer, size of the moving window (default
			2 periods)
bool recursive[0]:	0: rolling-window (default), 1: recursive
			(expanding) window

OUTPUT: series
+ Series of rolling/ recursively computed statistics based in 'y'
correctly aligned with time

-----------------
rolling_ts_gui():
-----------------
INPUT:
series y: 		series which is used for computing some
			statistics
string op:		string, name of the function you want to call
int wsize[1::2]:	integer, size of the moving window (default
			2 periods)
bool recursive[0]:	0: rolling-window (default), 1: recursive
			(expanding) window

OUTPUT: series
+ Series of rolling/ recursively computed statistics based in 'y'
correctly aligned with time
</help>
<gretl-function name="rolling_ts" type="matrix">
 <params count="5">
  <param name="y" type="list">
<description>List of series of interest</description>
  </param>
  <param name="op" type="string">
<description>Name of the function to call</description>
  </param>
  <param name="wsize" type="int" min="1" default="2">
<description>Size of the moving window</description>
  </param>
  <param name="recursive" type="bool" default="0">
<description>Recursive (expanding) window (default 0, rolling window)</description>
  </param>
  <param name="M" type="matricesref" optional="true">
<description>Store output in matrices object (optional)</description>
  </param>
 </params>
<code># Rolling Time-series Statistics
smpl --no-missing y
# set list or series properly
if nelem(y)==1
  series Y = y[1] # make sure that fun. which require a series work
else
  list Y = y		# ensure consistent naming
endif
# Moving window settings
scalar nsteps = $nobs - wsize + 1
smpl $t1 ($t1+wsize-1)
# RUN moving window
loop i=1..nsteps -q
  out = feval(op, Y)		# call function
  # Set up matrix or matrix array
  if i==1 	# Determine type of &quot;out&quot;
    string type = typestr(typeof(out))
    if type==&quot;matrix&quot; || type==&quot;scalar&quot;
      matrix ret = zeros(nsteps,cols(out))	# store results in matrix
    elif type==&quot;array&quot;
      if !exists(M)
        funcerr &quot;Please point to an matrix array in point form.&quot;
      endif
      matrices M = array(nelem(out))	# store results in matrices
      matrix ret = NA					# final function return value
    endif
  endif
  if type==&quot;array&quot;			# update each matrix in the array
    loop j=1..nelem(out) -q
      M[j] ~= out[j]		# concatenate each array element
    endloop
  else
    ret[i,] = vec(out)'		# update matrix entries
  endif
  if i&lt;nsteps
    if recursive==1
      smpl ; +1
    else
      smpl +1 +1
    endif
  endif
endloop
return ret
</code>
</gretl-function>
<gretl-function name="rvec2series" type="series">
 <params count="3">
  <param name="y" type="series">
<description>A reference series for grabbing correct dates</description>
  </param>
  <param name="mat" type="matrix">
<description>Information matrix (rows=moving windows, cols=variables)</description>
  </param>
  <param name="wsize" type="int" min="1" default="2">
<description>Size of the moving window</description>
  </param>
 </params>
<code># transform each column of ret into a series
# y is needed to make sure that ret has the correct date
smpl y --no-missing
smpl ($t1+wsize-1) $t2
#mat = vec(mat)
if nobs(y) != rows(mat)
  printf &quot;\nError: Number of observations in 'y' and the matrix are of different length.\n&quot;
  funcerr &quot;Check whether the current sample is correctly specified.&quot;
endif
series S = mat
setinfo S --description=&quot;rolling_ts() statistics&quot;
setinfo S --graph-name=&quot;rolling_ts() statistics&quot;
return S
</code>
</gretl-function>
<gretl-function name="rolling_ts_gui" type="series" menu-only="1" pkg-role="gui-main">
 <params count="4">
  <param name="y" type="series">
<description>Select series of interest</description>
  </param>
  <param name="op" type="string">
<description>Name of the function</description>
  </param>
  <param name="wsize" type="int" min="1" default="2">
<description>Size of the moving window</description>
  </param>
  <param name="recursive" type="bool" default="0">
<description>Recursive window (default 'rolling')</description>
  </param>
 </params>
<code>series S = rvec2series(y, rolling_ts(y, op, wsize, recursive), wsize)
printf &quot;\n Series computed\n&quot;
return S
</code>
</gretl-function>
<sample-script>
set verbose off
include RollingStats.gfn --force

open denmark.gdt -q		# load some time-series dataset
scalar wsize = 22		# set window lenght
scalar recursive = 0	# Moving-window type: 0=fixed window length, 1=expanding window

#----------------------
# (A) Use of rolling_ts
#----------------------
matrix mSK = rolling_ts(LRM, &quot;min&quot;, wsize)
series SK = rvec2series(LRM, mSK, wsize)
print SK -o

# Skewness
matrix mSK = rolling_ts(LRM, &quot;skewness&quot;, wsize)
series SK = rvec2series(LRM, mSK, wsize)
print SK -o

# Minimum -- &quot;one-liner&quot;
series MIN = rvec2series(LRM, rolling_ts(LRM, &quot;min&quot;, wsize, recursive), wsize)
print MIN -o

# Call your own user-defined function
# AR(1)-coefficient over time (w.o. intercept in the regression)
function scalar my_AR1 (const series y)
    ols y const y(-1) --quiet
    return $coeff[2]	# return AR(1) coeff.
end function 
# Call
matrix mbhat = rolling_ts(LRM, &quot;my_AR1&quot;, wsize, recursive)
series bhat = rvec2series(LRM, mbhat, wsize)
gnuplot bhat --with-lines --time-series --output=display



#----------------------------
# (B) Use of rolling_ts_list
#----------------------------
function matrices roll_bhat_ols (const list L)
    # Compute rolling OLS beta-coefficients
    # and standard errors
    series y = L[1]		# we expected the 1st entry being the endogenous
    L -= L[1]
    ols y L --quiet
    matrices M = array(2)
    M[1] = $coeff
    M[2] = $stderr
    return M
end function

# Call the user-defined function
list all = LRM const LRY				# list of the endogenous (1st entry) and regressors
matrices Mout = null					# put point estimates and std. errors into matrix array
rolling_ts(all, &quot;roll_bhat_ols&quot;, wsize, recursive, &amp;Mout)	# see the pointer form for Mout
print Mout
matrix mbhat = Mout[1]'					# grab rolling point estimates
strings regnames = varnames(all[2:])	# grab names of regressors
cnameset(mbhat, regnames)				# name the columns
matrix stderr = Mout[2]'				# grab rolling std. errors
cnameset(stderr, regnames)				# name the columns
printf &quot;\nRolling window estimation results:&quot;
print mbhat
#print stderr

# Transform each point estimate vector into a series
loop i=1..cols(mbhat) -q
    series Ser$i = rvec2series(LRM, mbhat[,i], wsize)
    string vnam = regnames[i]	
    setinfo Ser$i --graph-name=&quot;beta(@vnam)&quot;	# for showing name in graph
endloop
gnuplot Ser1 Ser2 --with-lines --time-series --output=display
</sample-script>
</gretl-function-package>
</gretl-functions>
