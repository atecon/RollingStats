function matrix rolling_ts (list y "List of series of interest",
                                 string op "Name of the function to call",
                                 int wsize[1::2] "Size of the moving window",
                                 bool recursive[0] "Recursive (expanding) window (default 0, rolling window)",
                                 matrices *M[null] "Store output in matrices object (optional)")

    # Rolling Time-series Statistics
    smpl --no-missing y

    # set list or series properly
    if nelem(y)==1
        series Y = y[1] # make sure that fun. which require a series work
    else
        list Y = y		# ensure consistent naming
    endif
    
    # Moving window settings    
    scalar nsteps = $nobs - wsize + 1
    smpl $t1 ($t1+wsize-1)

    # RUN moving window
    loop i=1..nsteps -q

        out = feval(op, Y)		# call function
            
        # Set up matrix or matrix array 
        if i==1 	# Determine type of "out"
            string type = typestr(typeof(out))
            if type=="matrix" || type=="scalar"
                matrix ret = zeros(nsteps,cols(out))	# store results in matrix
            elif type=="array"
                if !exists(M)
                    funcerr "Please point to an matrix array in point form."
                endif
                matrices M = array(nelem(out))	# store results in matrices
                matrix ret = NA					# final function return value
            endif
        endif
        
        if type=="array"			# update each matrix in the array
            loop j=1..nelem(out) -q
                M[j] ~= out[j]		# concatenate each array element
            endloop
        else            
            ret[i,] = vec(out)'		# update matrix entries
        endif

        if i<nsteps
            if recursive==1
                smpl ; +1
            else
                smpl +1 +1
            endif
        endif
    endloop
    return ret
end function


function series rvec2series (series y "A reference series for grabbing correct dates",
                             matrix mat "Information matrix (rows=moving windows, cols=variables)",
                             int wsize[1::2] "Size of the moving window")
    # transform each column of ret into a series
    # y is needed to make sure that ret has the correct date
    smpl y --no-missing
    smpl ($t1+wsize-1) $t2
    #mat = vec(mat)
    if nobs(y) != rows(mat)
        printf "\nError: Number of observations in 'y' and the matrix are of different length.\n"
        funcerr "Check whether the current sample is correctly specified."
    endif
    series S = mat
    setinfo S --description="rolling_ts() statistics"
    setinfo S --graph-name="rolling_ts() statistics"
    return S
end function

/* FOR FUTURE VERSIONS
function list rvec2series (series y "A reference series for grabbing correct dates",
                           matrix mat "Information matrix (rows=moving windows, cols=variables)",
                             int wsize[1::2] "Size of the moving window")
    # transform each column of ret into a series
    # y is needed to make sure that ret has the correct date
    smpl y --no-missing
    smpl ($t1+wsize-1) $t2
    #mat = vec(mat)
    if nobs(y) != rows(mat)
        printf "\nError: Number of observations in 'y' and the matrix are of different length.\n"
        funcerr "Check whether the current sample is correctly specified."
    endif
    list L = null
    loop i=1..cols(mat) -q
        series Rolling_Series_$i = mat[,i]
        L += Rolling_Series_$i
        setinfo Rolling_Series_$i --description="rolling_ts() series"
        setinfo Rolling_Series_$i --graph-name="rolling_ts() series $i"
    endloop
    return L
end function
*/

function series rolling_ts_gui (series y "Select series of interest",
                                string op "Name of the function",
                                int wsize[1::2] "Size of the moving window",
                                bool recursive[0] "Recursive window (default 'rolling')")

    series S = rvec2series(y, rolling_ts(y, op, wsize, recursive), wsize)
    printf "\n Series computed\n"
    return S
end function

/*
   function matrix skew (matrix X)
   # URL: http://de.mathworks.com/help/stats/skewness.html?requestedDomain=www.mathworks.com

   matrix xbar = X.-meanc(X)
   scalar A = 1/rows(X) .* sumc(xbar.^3)
   scalar B = ( sqrt(1/rows(X) .* sumc(xbar.^2) )).^3
   scalar S1 = A/B
   scalar S0a = sqrt(rows(X)*(rows(X)-1))
   scalar S0b = rows(X)-2
   S0 = S0a*S1/S0b				# bias-corrected formula, ==gretl's default

   return S0~S1
   end function
*/
