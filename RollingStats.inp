function matrix rolling_ts (list y "List of series of interest",
                                 string op "Name of the function to call",
                                 int wsize[1::2] "Size of the moving window",
                                 bool recursive[0] "Recursive (expanding) window (default 0, rolling window)",
                                 matrices *M[null] "Store output in matrices object (optional)")

    # Rolling Time-series Statistics
    smpl --no-missing y

    # set list or series properly
    if nelem(y)==1
        series Y = y[1] # make sure that fun. which require a series work
    else
        list Y = y		# ensure consistent naming
    endif
    
    # Moving window settings    
    scalar nsteps = $nobs - wsize + 1
    smpl $t1 ($t1+wsize-1)

    # RUN moving window
    loop i=1..nsteps -q

        out = feval(op, Y)		# call function
            
        # Set up matrix or matrix array 
        if i==1 	# Determine type of "out"
            string type = typestr(typeof(out))
            if type=="matrix" || type=="scalar"
                matrix ret = zeros(nsteps,cols(out))	# store results in matrix
            elif type=="array"
                if !exists(M)
                    funcerr "Please point to an matrix array in point form."
                endif
                matrices M = array(nelem(out))	# store results in matrices
                matrix ret = NA					# final function return value
            endif
        endif
        
        if type=="array"			# update each matrix in the array
            loop j=1..nelem(out) -q
                M[j] ~= out[j]		# concatenate each array element
            endloop
        else            
            ret[i,] = vec(out)'		# update matrix entries
        endif

        if i<nsteps
            if recursive==1
                smpl ; +1
            else
                smpl +1 +1
            endif
        endif
    endloop
    return ret
end function


function series rvec2series (series y "Reference series",
                             matrix ret "Computed vector",
                             int wsize[1::2] "Size of the moving window")
    # transform 'ret' into series
    # y is needed to market that ret has the correct date
    smpl y --no-missing
    smpl ($t1+wsize-1) $t2
    ret = vec(ret)
    if nobs(y) != rows(ret)
        printf "\nError: Vector 'm' has not the right length.\n"
        funcerr "Check whether the current sample is correctly specified."
    endif
    series S = ret
    setinfo S --description="rolling_ts() statistics"
    setinfo S --graph-name="rolling_ts() statistics"
    return S
end function

function series rolling_ts_gui (series y "Select series of interest",
                                string op "Name of the function",
                                int wsize[1::2] "Size of the moving window",
                                bool recursive[0] "Recursive window (default 'rolling')")

    series S = rvec2series(y, rolling_ts(y, op, wsize, recursive), wsize)
    printf "\n Series computed\n"
    return S
end function

/*
   function matrix skew (matrix X)
   # URL: http://de.mathworks.com/help/stats/skewness.html?requestedDomain=www.mathworks.com

   matrix xbar = X.-meanc(X)
   scalar A = 1/rows(X) .* sumc(xbar.^3)
   scalar B = ( sqrt(1/rows(X) .* sumc(xbar.^2) )).^3
   scalar S1 = A/B
   scalar S0a = sqrt(rows(X)*(rows(X)-1))
   scalar S0b = rows(X)-2
   S0 = S0a*S1/S0b				# bias-corrected formula, ==gretl's default

   return S0~S1
   end function
*/
