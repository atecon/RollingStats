function matrix rolling_ts (series y "Series of interest",
                            string op "Name of the function to call",
                            int wsize[1::2] "Size of the moving window",
                            bool recursive[0] "Recursive (expanding) window (default 0, rolling window)")

    # rolling_ts -- Rolling Time-series Statistics
    smpl y --no-missing
    scalar nsteps = nobs(y) - wsize + 1
    matrix ret = zeros(nsteps,1)	# store results
    smpl $t1 ($t1+wsize-1)

    loop i=1..nsteps -q
        ret[i] = feval(op, y)	# call function
        if i<nsteps
            if recursive==1
                smpl ; +1
            else
                smpl +1 +1
            endif
        endif
    endloop
    return ret
end function

function matrices rolling_ts_list (list y "List of interest",
                            string op "Name of the function to call",
                            int wsize[1::2] "Size of the moving window",
                            bool recursive[0] "Recursive (expanding) window (default 0, rolling window)")

    # rolling_ts -- Rolling Time-series Statistics
    smpl --no-missing y
    scalar nsteps = $nobs - wsize + 1    
    smpl $t1 ($t1+wsize-1)

    loop i=1..nsteps -q        
        matrices mat = feval(op, y)		# call function
        matrices ret = (i==1) ? array(nelem(mat)) : ret 	# for storing final results        
        # update each matrix in matrices
        loop j=1..nelem(mat) -q
            ret[j] ~= mat[j]	# grab last version of j-th matrix in ret
            matrix m = ret[j]
            ret[j] = m		# update j-th matrix in ret
        endloop
        if i<nsteps
            if recursive==1
                smpl ; +1
            else
                smpl +1 +1
            endif
        endif
    endloop
    return ret
end function

function series rvec2series (series y "Reference series",
                             matrix ret "Computed vector",
                             int wsize[1::2] "Size of the moving window")
    # transform 'ret' into series
    # y is needed to market that ret has the correct date
    smpl y --no-missing
    smpl ($t1+wsize-1) $t2
    ret = vec(ret)
    if nobs(y) != rows(ret)
        printf "\nError: Vector 'm' has not the right length.\n"
        funcerr "Check whether the current sample is correctly specified."
    endif
    series S = ret
    setinfo S --description="rolling_ts() statistics"
    setinfo S --graph-name="rolling_ts() statistics"
    return S
end function

function series rolling_ts_gui (series y "Select series of interest",
      string op "Name of the function",
      int wsize[1::2] "Size of the moving window",
      bool recursive[0] "Recursive window (default 'rolling')")

    series S = rvec2series(y, rolling_ts(y, op, wsize, recursive), wsize)
    printf "\n Series computed\n"
    return S
end function

/*
   function matrix skew (matrix X)
   # URL: http://de.mathworks.com/help/stats/skewness.html?requestedDomain=www.mathworks.com

   matrix xbar = X.-meanc(X)
   scalar A = 1/rows(X) .* sumc(xbar.^3)
   scalar B = ( sqrt(1/rows(X) .* sumc(xbar.^2) )).^3
   scalar S1 = A/B
   scalar S0a = sqrt(rows(X)*(rows(X)-1))
   scalar S0b = rows(X)-2
   S0 = S0a*S1/S0b				# bias-corrected formula, ==gretl's default

   return S0~S1
   end function
*/
