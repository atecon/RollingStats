function scalar data_has_missings (const list L)
    /* code description
    return: type, description */

    has_missings = sum(missing(L))
    if has_missings
        print "ERROR: Some of the series has missing values. Remove first."
    endif
    scalar has_missings == FALSE ? FALSE : TRUE

    return has_missings
end function


function scalar get_nsteps (const int wsize)
    /* Compute number of interations. */

    nsteps = $nobs - wsize + 1
    errorif(nsteps <= 0, "Not enough observations for selected window length.")

    return nsteps
end function


# TODO: make use of the generic feature: y could be a series or list (maybe even matrix?)
# TODO: I do not want to have a 4 argument function
function bundle rolling (const list L "Target series",
                         const string operation "Function to call",
                         int wsize[1::2] "Length of the window",
                         bool expanding[FALSE] "Do expanding window")
    /* Compute moving statistics. */

    bundle self = _(T = $nobs, error = FALSE, operation, wsize, expanding)
    scalar self.error = data_has_missings(L)

    if self.error
        return self
    endif

    self.nsteps = get_nsteps(self.wsize)

    compute_moving_stats(L, &self)

    return self
end function


function bundle compute_moving_stats (const list L,
                                      bundle *self)
    /*  Actual computation is done here. */

    # Initial sample
    if nelem(L) == 1
        series Y = L[1]
    else
        list Y = L
    endif

    smpl $t1 ($t1 + self.wsize - 1)
    strings self.dates = array(self.nsteps)

    loop i=1..self.nsteps
        out = feval(self.operation, Y)
        self.dates[i] = obslabel($t2)

        if i == 1
            string dtype = typestr(typeof(out))

            # TODO: put into separate function
            if dtype == "matrix"
                matrix self.results = mshape(NA, self.nsteps, cols(out))
            elif dtype ==  "scalar"
                matrix self.results = mshape(NA, self.nsteps, 1)
            elif dtype == "array"
                matrices self.results = array(nelem(out))
            else
                funcerr "Operation returned unsupported datatype."
            endif
        endif

        if dtype == "array"
            loop j=1..nelem(out)
                self.results[j] |= out[j]'      # concatenate each array element
            endloop
        elif dtype == "matrix" || dtype == "scalar"
            self.results[i,] = vec(out)'
        endif

        if i < self.nsteps
            if self.expanding
                smpl ; +1
            else
                smpl +1 +1
            endif
        endif
    endloop

    rnameset(self.results, self.dates)

    return self
end function


function series rvec2series (const matrix mat "Rows. mov. windows, Cols: vars",
                             int wsize[1::2] "Moving-window size")
    /* Transform each column of 'mat' into a series. */

    smpl ($t1 + wsize - 1) $t2

    errorif($nobs != rows(mat),\
        "Number of observations of active dataset and the matrix are of different length.")

    series S = mat
    setinfo S --description="rolling_ts() statistics"
    setinfo S --graph-name="rolling_ts() statistics"

    return S
end function


function series moving_stats_gui (const series y "Series of interest",
                                  const string operation "Name of the function",
                                  int wsize[1::2] "Size of the moving window",
                                  bool expanding[0] "Recursive window")
    /* */
    series S = rvec2series(moving_stats(y, operation, wsize, expanding),\
                           wsize)
    print "Series succesfully computed."

    return S
end function

/*
   function matrix skew (matrix X)
   # URL: http://de.mathworks.com/help/stats/skewness.html?requestedDomain=www.mathworks.com

   matrix xbar = X.-meanc(X)
   scalar A = 1/rows(X) .* sumc(xbar.^3)
   scalar B = ( sqrt(1/rows(X) .* sumc(xbar.^2) )).^3
   scalar S1 = A/B
   scalar S0a = sqrt(rows(X)*(rows(X)-1))
   scalar S0b = rows(X)-2
   S0 = S0a*S1/S0b				# bias-corrected formula, ==gretl's default

   return S0~S1
   end function
*/
